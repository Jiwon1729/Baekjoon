# Feedback
## 230214
### 1644
- 소수를 찾을 때 dp 방식을 이용하였는데, 속도가 느려 알아본 결과 에라토스테네스 체 방법이 있다는 것을 발견 후 사용

### 1766
- 우선순위를 가장 낮은 문제를 풀 때 선행하는 것을 먼저 풀어야 한다고 생각함. 실제로는 먼저 풀 수 있는 문제들 중 가장 숫자가 낮은 것을 뽑아야 했음.
- 1 문제를 풀 면 먼저 풀 수 있는 문제의 종류가 달라지므로, 우선순위를 다시 재정렬 해주어야 함
#### 위상정렬
1. 진입차수가 0인 정점을 큐에 삽입
2. 큐에서 원소를 꺼내 해당 원소와 연결된 간선을 모두 제거
3. 제거한 후에 진입차수가 0인 정점을 큐에 삽입
4. 이후 2~3의 과정을 반복

### 12100
#### Copy and Deepcopy

#### List 2차원 정렬
- Trnspose: matrix = [list(x) for x in zip(*matrix)]
- *는 unpacking zip은 여러 개의 리스트 각 요소를 합쳐줌
- 상하 변경
    for i in range(N):
        tmp = matrix[i]
        tmp.reverse()
        matrix2.append(tmp)

### 20040
- iteration 횟수 증가: sys.setrecursionlimit(10**7)
- unionfind

### 17387
- 두 선분이 일치하는 경우에는 따로 처리해야 한다는 것을 고려하지 못함
#### CCW 
- https://gaussian37.github.io/math-algorithm-ccw/ 참고
- 외적을 통해 결과가 음수면 시계뱡향, 양수면 반시계방향으로 벡터를 통해 방향을 구하는 방법

### 16724
- cycle이 먼저 있지 않은 경우에 대해서 고려하지 못함

### 1509
- 펠린드롬을 할 때 mid값을 기준으로 해야 이전 펠린드롬을 사용하기 용이한 것을 간과하고 dp를 사용함(펠린드롬 경우의 수에서는 dp를 사용하지 않았음)

### list.count(#): list에 있는 #의 개수를 반환
